[文档参考地址](http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/)

[更多文章](https://github.com/woai30231/webDevDetails)

### 说明

下面代码演示基于window系统chrome浏览器环境，版本号为63.0.3239.132，32位！相关结果可能会有一点出入，请也实际为准！

相关代码调试的过程中查看结果的步骤：

* 打开浏览器控制台，切换到sources板块，并选择相应的源文件；

* 在对应的源文件代码左边的行号上打上断点；

* 然后刷新浏览器，浏览器会在对应打断点的代码出停止执行，此时我们根据需要按f11键一步一步的运行代码，并同时查看代码的调用栈，作用域等情况，主要查看source板块下最右边子板块的Call Stack和Scope项。

### 相关概念梳理

其实从我自身出发，我觉的如果需要更好地理解变量对象的话，那么需要对以下概念有一个比较基本的理解会更方便些！

* **函数调用栈**

为了理解函数调用栈，我们先写一段代码：

```javascript
  function fn1(){
    console.log('fn1');
    fn2();
  };
  function fn2(){
    console.log('fn2');
  };
  fn1();
```
我们在fn2函数调用的地方打上断点，然后刷新浏览器，查看Call Stack选项，会看到下面的结果：

```bash
  fn1
  (anonymous)
```
此时再按一次f11键，此时Call Stack显示结果如下：

```bash
  fn2
  fn1
  (anonymous)
```
这里说明一下，anonymous指代全局匿名调用函数环境，而fn1和fn2分别指代fn1函数作用域和fn2作用域环境。

我们梳理一下浏览器的调用过程：1 js进入全局匿名函数环境，把这个所谓的匿名函数推入调用栈；2 发现此时又调用了fn1，于是把fn1函数推入调用栈，此时fn1在anonymous的上面； 3 紧接着，发现调用了fn2，于是把fn2推入调用栈，于是得到了上面的结果。

如果后续我们继续按f11键调试，会发现Call Stack会依次出现先面的结果：

```bash
  fn2
  fn1
  (anonymous)
```

```bash
  fn1
  (anonymous)
```

```bash
  (anonymous)
```
也就是说最后只剩下了全局匿名函数环境，这里强调一下，anonymous环境将会伴随着程序运行一直存在，除非你关闭了浏览器。

于是我们总结得到这样的结果：存在这样一个调用栈，默认推入一个全局匿名函数在栈底，当此时再调用其它全局函数的时候，会把该函数推入栈，并在anonymous上面，如果该函数内部继续调用了其它函数，那么同样道理，会把其它函数推入栈，放在该函数上面，最后当函数在调用完成的过程中，会依次退出该调用栈，退出的过程中会把权限交给上一层函数，最后又回归了只剩下全局匿名函数环境。于是我们说了这么多，其实这就是函数调用栈！

函数调用栈你可以理解为函数调用前后包含关系：先进后出，后进先出！

* **函数作用域**

* **闭包**








